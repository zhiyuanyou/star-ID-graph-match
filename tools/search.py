# -*- coding: utf-8 -*-
"""
This code is used to search the best match between the test graph & the databse 
graph. The graph match algorithm is relatively slow so far. However, it is very 
important that it is not a single star match or a pattern match, when the graph 
match is done, every star in the graph is matched with the database. 

Written in 2020.01.26, revised in 2022.12.06
by Zhiyuan You
"""


import glob
import numpy as np
import joblib
import os

from easydict import EasyDict

from utils.search.select_R_AD_helper import select_R_AD
from utils.search.graph_helper import gen_graph
from utils.common.mst_helper import gen_mst
from utils.search.k_vector_helper import search_k_vector
from utils.search.match_helper import match_graph


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec: Declination
# AD: angular distance
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# R: Radius
# _ms: main star
# _ns: neighbor star
# _s: star, main star & neighbor star
# _thre: threshold


def search(filepaths, k_vector_q_m, graph_list, para, visualization=False):
    num_fail = 0
    num_right = 0
    num_wrong = 0

    k_vector, q, m = k_vector_q_m

    for filepath in filepaths:
        with open(filepath) as fr:
            lines = fr.readlines()
        CN_ms = int(lines[0].strip().split()[0])
        print(f"Handling star {CN_ms}")

        # select R
        lines_out = select_R_AD(lines, para)

        # generate graph
        graph = gen_graph(lines_out, para)

        # generate mst
        graph, _ = gen_mst(graph)

        # rough search
        i_interval_start = None
        i_interval_end = None
        for epsilon_AD in para.epsilon_AD_list:
            i_start, i_end = search_k_vector(
                graph["AD_sum_mst"], k_vector, q, m, epsilon_AD
            )
            if i_interval_start == None or i_interval_end == None:
                assert i_interval_start == i_interval_end
                i_graph_list = range(i_start, i_end + 1)
            else:
                i_graph_list = list(range(i_start, i_interval_start)) + list(
                    range(i_interval_end + 1, i_end + 1)
                )
            i_interval_start, i_interval_end = i_start, i_end

            # graph match
            min_error = float("inf")
            for i_graph in i_graph_list:
                graph_candidata = graph_list[i_graph]

                # load 2 graph's adjacency matrix for match
                M_adj_g1 = graph["M_adj"]
                M_adj_g2 = graph_candidata["M_adj"]

                num_star1 = M_adj_g1.shape[0]
                num_star2 = M_adj_g2.shape[0]
                if abs(num_star1 - num_star2) > int(0.2 * num_star2):
                    continue

                error = match_graph(M_adj_g1, M_adj_g2, para)

                if error < min_error:
                    i_target = i_graph
                    min_error = error

            CN_ms_candidat = int(graph_list[i_target]["CN_ms"])
            # if the min_error is smaller than the epsilon_error, the search is done.
            # else, continue to search.
            if min_error <= para.epsilon_error:
                break

        if min_error > para.epsilon_error:
            num_fail += 1
        elif CN_ms == CN_ms_candidat:
            num_right += 1
        else:
            num_wrong += 1
        print(f"Right: {num_right}, Wrong: {num_wrong}, Fail: {num_fail}")

    acc = num_right / (num_right + num_wrong)
    fail_rate = num_fail / (num_fail + num_right + num_wrong)
    print(f"Accuracy: {acc}, Failure Rate: {fail_rate}")


if __name__ == "__main__":
    # simulation parameter
    para = EasyDict({})
    # hyper parameter
    # the affinity between 2 edges are defined as 1/exp(abs(AD1-AD2)), AD belongs to
    # about (0,12), the difference need to be adjusted. Redefine difference:
    # 1/exp(times_sub_AD*abs(AD1-AD2)).
    para.times_sub_AD = 1.74
    # Radius of AD that generate a graph
    para.R_AD = 6
    # the AD uncertainty during the process of rough search through k-vector
    para.epsilon_AD_list = np.linspace(0.1, 6, 500)
    # the error threshold
    para.epsilon_error = 0.4
    para.FOV_x = 20  # FOV
    para.FOV_y = 20
    para.N_x = 1024  # resolution
    para.N_y = 1024
    para.VM_thre = 6.0
    para.R_max = 5
    para.Color = (255, 255, 255)

    # graph
    para.Color_s = (0, 0, 0)
    para.Color_l = (0, 0, 0)
    para.Wid_l = 1
    para.Wid_s = -1  # -1: filled
    para.R_s = 5  # the graph vextex radius

    database_txt_dir = "./database/txt_star_image"
    filepaths = glob.glob(os.path.join(database_txt_dir, "*.txt"))

    k_vector, q, m = joblib.load("./database/k_vector_q_m.pkl")
    graph_list = joblib.load("./database/graph_list.pkl")

    search(filepaths, [k_vector, q, m], graph_list, para)
