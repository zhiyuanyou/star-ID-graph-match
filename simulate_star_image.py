# -*- coding: utf-8 -*-
"""
This code is used to generate simulation star images through RightAscension & 
Declination of the stars in FOV of CCD.

The project model of one star is described in 'project_1s' function.

According to the project model, the main star is projected to the center of the 
image. The neighbor star whose AD (angular distance) with main star is less than 
FOV_max is project in the image.

Revised in 2020.4.13
By YouZhiyuan
"""

import cv2
import math
import numpy as np
import os
from easydict import EasyDict


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec:  Declination
# AD: angular distance
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# _ms: main star
# _ns: neighbor star
# _thre: threshold
# _1s: one star
# _2s: double star


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


def simulate_all_stars(
    f_sao_name, database_txt_dir, database_pic_dir, para_simu, visualization=True
):
    # read the SAO database
    with open(f_sao_name) as fr:
        lines = fr.readlines()

    num_star = len(lines)
    for i_ms in range(num_star):
        CN_ms = lines[i_ms].strip().split()[0]
        lines_out, img = simulate_one_star(lines, i_ms, para_simu)
        if lines_out:
            # save generated txt file
            txt_path = os.path.join(database_txt_dir, str(CN_ms) + ".txt")
            with open(txt_path, "w") as fw:
                for line in lines_out:
                    fw.write(line)
            # save generated image
            if visualization:
                img_path = os.path.join(database_pic_dir, str(CN_ms) + ".jpg")
                cv2.imwrite(img_path, img)
            print(f"Successfully generated txt file and image for {CN_ms}")


def simulate_one_star(lines, i_ms, para_simu):
    num_star = len(lines)
    lines_out = []

    data_ms = lines[i_ms].strip().split()
    assert len(data_ms) == 4

    # generate unit vector for calculating angular distance
    CN_ms, VM_ms, RA_ms, Dec_ms = np.float32(data_ms)
    CN_ms = int(CN_ms)
    vz_ms = np.sin(Dec_ms)
    vx_ms = np.cos(RA_ms) * np.cos(Dec_ms)
    vy_ms = np.sin(RA_ms) * np.cos(Dec_ms)

    # write main star into txt file
    CN_ms_str, VM_ms_str, RA_ms_str, Dec_ms_str = data_ms
    # CN VM x_pixel y_pixel RA Dec
    lines_out.append(f"{CN_ms_str} {VM_ms_str} {0} {0} {RA_ms_str} {Dec_ms_str}\n")

    img = np.zeros((para_simu.N_y, para_simu.N_x, 3), np.uint8)
    # write main star into image
    x_pixel, y_pixel = para_simu.N_x // 2, para_simu.N_y // 2
    R = min(
        int((para_simu.VM_thre - VM_ms) / para_simu.VM_thre * para_simu.R_max) + 1,
        para_simu.R_max,
    )  # the darkest is 1, the brightest is R_max
    cv2.circle(img, (x_pixel, y_pixel), R, para_simu.Color, -1)

    for i_ns in range(num_star):
        if i_ns == i_ms:
            continue  # main star has been written.

        data_ns = lines[i_ns].strip().split()
        assert len(data_ns) == 4

        # generate unit vector for calculating angular distance
        CN_ns, VM_ns, RA_ns, Dec_ns = np.float32(data_ns)
        CN_ns = int(CN_ns)
        vx_ns = np.cos(RA_ns) * np.cos(Dec_ns)
        vy_ns = np.sin(RA_ns) * np.cos(Dec_ns)
        vz_ns = np.sin(Dec_ns)

        # AD_ms_ns: the angular distance between main star & neighbor star
        cos = vx_ns * vx_ms + vy_ns * vy_ms + vz_ns * vz_ms
        try:
            assert abs(cos) <= 1
            AD_ms_ns = np.arccos(cos) * rad2deg
        except:
            print(f"Error caused by double-satr system: {CN_ms} & {CN_ns}")
            print("Cos of inertial angular distance: " + str(cos))
            AD_ms_ns = np.arccos(np.clip(cos, -1, 1)) * rad2deg

        if AD_ms_ns < para_simu.FOV_max:
            # x_ns, y_ns: the project coordinate of neighbor star
            x_ns, y_ns = project_1s(
                Dec_ms,
                RA_ms,
                Dec_ns,
                RA_ns,
                para_simu.N_x,
                para_simu.N_y,
                para_simu.FOV_x,
                para_simu.FOV_y,
            )
            if abs(x_ns) > para_simu.N_x // 2 or abs(y_ns) > para_simu.N_y // 2:
                # fall outside of the FOV
                pass
            else:
                # write txt file
                CN_ns_str, VM_ns_str, RA_ns_str, Dec_ns_str = data_ns
                lines_out.append(
                    f"{CN_ns_str} {VM_ns_str} {x_ns} {y_ns} {RA_ns_str} {Dec_ns_str}\n"
                )

                # write image
                x_pixel = int(x_ns + para_simu.N_x // 2)  # in cv2: (x,y)
                y_pixel = int(y_ns + para_simu.N_y // 2)
                R = min(
                    int(
                        (para_simu.VM_thre - VM_ns)
                        / para_simu.VM_thre
                        * para_simu.R_max
                    )
                    + 1,
                    para_simu.R_max,
                )  # the darkest is 1, the brightest is R_max
                cv2.circle(img, (x_pixel, y_pixel), R, para_simu.Color, -1)

            # if the main star belogs to a double star system
            if AD_ms_ns <= para_simu.AD_2s_thre:
                return None, None

    return lines_out, img


# the project model of one star
def project_1s(Dec, RA, Dec_i, RA_i, N_x, N_y, FOV_x, FOV_y):
    # input:
    # Dec,RA: the Dec & RA of the optical axis
    # Dec_i,RA_i: the Dec & RA of the ith star
    # N_x,N_y: the resolution of the picture
    # FOV_x,FOV_y: the FOV of the CCD
    # calculate the rotate matrix Rx by theta_x
    # output:
    # Xr,Yr: the pixel coordinate of the image
    theta_x = -(math.pi / 2 - Dec)
    Rx = [
        [1, 0, 0],
        [0, np.cos(theta_x), np.sin(theta_x)],
        [0, -np.sin(theta_x), np.cos(theta_x)],
    ]
    # calculate the rotate matrix Rz by theta_z
    theta_z = -(math.pi / 2 - RA)
    Rz = [
        [np.cos(theta_z), np.sin(theta_z), 0],
        [-np.sin(theta_z), np.cos(theta_z), 0],
        [0, 0, 1],
    ]
    R = np.matmul(Rx, Rz)
    # calculate the inertial vector in inertial space
    v_inertial = [
        np.cos(RA_i) * np.cos(Dec_i),
        np.sin(RA_i) * np.cos(Dec_i),
        np.sin(Dec_i),
    ]
    # transfer the inertial vector to body vector in CCD space
    v_body = np.matmul(R, v_inertial)
    # project to the pixel coordinate (the space origin is the center of the image)
    Xr = -v_body[0] / v_body[2] * N_x / 2 / np.tan(FOV_x / 2 * deg2rad)
    Yr = -v_body[1] / v_body[2] * N_y / 2 / np.tan(FOV_y / 2 * deg2rad)
    return Xr, Yr


if __name__ == "__main__":
    # simulation parameter
    para_simu = EasyDict({})
    para_simu.AD_2s_thre = 0.19  # AD threshold for 2 star systme
    para_simu.FOV_x = 20  # FOV
    para_simu.FOV_y = 20
    para_simu.FOV_max = np.sqrt((para_simu.FOV_x / 2) ** 2 + (para_simu.FOV_y / 2) ** 2)
    para_simu.N_x = 1024  # resolution
    para_simu.N_y = 1024
    para_simu.VM_thre = 6.0
    para_simu.R_max = 5
    para_simu.Color = (255, 255, 255)

    f_sao_name = f"database/sao_VM_thre{para_simu.VM_thre}.txt"

    # create database pic dir to save simulation image
    database_pic_dir = "database/pic_star_image"
    os.makedirs(database_pic_dir, exist_ok=True)
    # create database txt dir to save simulation txt file
    # txt format:
    # 0 row: CN_ms,VM_ms,x_ms,y_ms,RA_ms,Dec_ms
    # other rows: CN_ns,VM_ns,x_ns,y_ns,RA_ns,Dec_ns
    database_txt_dir = "database/txt_star_image"
    os.makedirs(database_txt_dir, exist_ok=True)

    simulate_all_stars(f_sao_name, database_txt_dir, database_pic_dir, para_simu)
