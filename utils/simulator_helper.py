# -*- coding: utf-8 -*-
"""
This code is used to generate simulation star images through RightAscension & 
Declination of the stars in FOV of CCD.

The project model of one star is described in 'project_1s' function.

According to the project model, the main star is projected to the center of the 
image. The neighbor star whose AD (angular distance) with main star is less than 
FOV_max is project in the image.

written in 2020.04.13, revised in 2022.12.06
By Zhiyuan You
"""

import math
import numpy as np


# CN: Catalog Number
# VM: Visual Magnitude
# RA: Right Ascension
# Dec: Declination
# AD: Angular Distance
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# _ms: main star
# _ns: neighbor star
# _thre: threshold
# _1s: one star
# _2s: double star


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


def simulate_one_star(lines, i_ms, para_simu):
    num_star = len(lines)
    lines_out = []

    data_ms = lines[i_ms].strip().split()
    assert len(data_ms) == 4

    # generate unit vector for calculating angular distance
    CN_ms, VM_ms, RA_ms, Dec_ms = data_ms
    CN_ms, VM_ms, RA_ms, Dec_ms = int(CN_ms), float(VM_ms), float(RA_ms), float(Dec_ms)
    vz_ms = np.sin(Dec_ms)
    vx_ms = np.cos(RA_ms) * np.cos(Dec_ms)
    vy_ms = np.sin(RA_ms) * np.cos(Dec_ms)

    # write main star into txt file: CN VM x_pixel y_pixel
    x_ms = y_ms = 0
    lines_out.append(f"{CN_ms} {VM_ms} {x_ms} {y_ms} {RA_ms} {Dec_ms}\n")

    for i_ns in range(num_star):
        if i_ns == i_ms:
            continue  # main star has been written.

        data_ns = lines[i_ns].strip().split()
        assert len(data_ns) == 4

        # generate unit vector for calculating angular distance
        CN_ns, VM_ns, RA_ns, Dec_ns = data_ns
        CN_ns, VM_ns, RA_ns, Dec_ns = (
            int(CN_ns),
            float(VM_ns),
            float(RA_ns),
            float(Dec_ns),
        )
        vx_ns = np.cos(RA_ns) * np.cos(Dec_ns)
        vy_ns = np.sin(RA_ns) * np.cos(Dec_ns)
        vz_ns = np.sin(Dec_ns)

        # AD_ms_ns: the angular distance between main star & neighbor star
        # if there are some numerous errors, |cos| may slightly > 1
        cos = vx_ns * vx_ms + vy_ns * vy_ms + vz_ns * vz_ms
        AD_ms_ns = np.arccos(np.clip(cos, -1, 1)) * rad2deg

        if AD_ms_ns < para_simu.FOV_max:
            # x_ns, y_ns: the project coordinate of neighbor star
            x_ns, y_ns = project_1s(
                Dec_ms,
                RA_ms,
                Dec_ns,
                RA_ns,
                para_simu.N_x,
                para_simu.N_y,
                para_simu.FOV_x,
                para_simu.FOV_y,
            )
            if abs(x_ns) > para_simu.N_x // 2 or abs(y_ns) > para_simu.N_y // 2:
                # fall outside of the FOV
                pass
            else:
                # write neighbor star into txt file: CN VM x_pixel y_pixel
                lines_out.append(f"{CN_ns} {VM_ns} {x_ns} {y_ns} {RA_ns} {Dec_ns}\n")

            # if the main star belogs to a double star system
            if AD_ms_ns <= para_simu.AD_2s_thre:
                return None

    return lines_out


# the project model of one star
def project_1s(Dec, RA, Dec_i, RA_i, N_x, N_y, FOV_x, FOV_y):
    # input:
    # Dec,RA: the Dec & RA of the optical axis
    # Dec_i,RA_i: the Dec & RA of the ith star
    # N_x,N_y: the resolution of the picture
    # FOV_x,FOV_y: the FOV of the CCD
    # calculate the rotate matrix Rx by theta_x
    # output:
    # Xr,Yr: the pixel coordinate of the image
    theta_x = -(math.pi / 2 - Dec)
    Rx = [
        [1, 0, 0],
        [0, np.cos(theta_x), np.sin(theta_x)],
        [0, -np.sin(theta_x), np.cos(theta_x)],
    ]
    # calculate the rotate matrix Rz by theta_z
    theta_z = -(math.pi / 2 - RA)
    Rz = [
        [np.cos(theta_z), np.sin(theta_z), 0],
        [-np.sin(theta_z), np.cos(theta_z), 0],
        [0, 0, 1],
    ]
    R = np.matmul(Rx, Rz)
    # calculate the inertial vector in inertial space
    v_inertial = [
        np.cos(RA_i) * np.cos(Dec_i),
        np.sin(RA_i) * np.cos(Dec_i),
        np.sin(Dec_i),
    ]
    # transfer the inertial vector to body vector in CCD space
    v_body = np.matmul(R, v_inertial)
    # project to the pixel coordinate (the space origin is the center of the image)
    Xr = -v_body[0] / v_body[2] * N_x / 2 / np.tan(FOV_x / 2 * deg2rad)
    Yr = -v_body[1] / v_body[2] * N_y / 2 / np.tan(FOV_y / 2 * deg2rad)
    return Xr, Yr
