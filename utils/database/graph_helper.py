# -*- coding: utf-8 -*-
"""
This code is used to generate graph of every main star. 

Each graph is a dictionary, which has the key-value: 'CN_ms':CN_ms,'M_adj':M_adj. 

Note that the following graph match is based only on edges, so the diagonals of 
adjacency matrix M_adj are 0.

Written in 2020.01.26, revised in 2022.12.06
by Zhiyuan You
"""

import math
import numpy as np


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec:  Declination
# AD: angular distance
# M: matrix
# R: Radius
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# Wid: width
# x,y: the project coordinate
# _adj: adjacency
# _diag: diagonal
# _l: line
# _ms: main star
# _n0: none zero
# _ns: neighbor star
# _s: star
# _thre: threshold


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


def gen_graph(lines):
    num_star = len(lines)

    graph = dict()

    # handle the main star
    CN_ms = int(lines[0].strip().split()[0])

    # add 2 key-values to the graph dict
    graph["CN_ms"] = CN_ms
    # CatalogNumber of the graph
    CN_list = []
    # X,Y in pixel space of the stars
    XY_list = []

    # construct the adjacency matrix for the graph
    M_adj = np.ones((num_star, num_star)) * float("inf")

    for i_s1 in range(num_star):
        data_s1 = lines[i_s1].strip().split()
        assert len(data_s1) == 6

        CN_s1, _, x_s1, y_s1, RA_s1, Dec_s1 = data_s1
        CN_s1, x_s1, y_s1, RA_s1, Dec_s1 = (
            int(CN_s1),
            float(x_s1),
            float(y_s1),
            float(RA_s1),
            float(Dec_s1),
        )
        CN_list.append(CN_s1)
        XY_list.append((x_s1, y_s1))

        # generate unit vector for calculating angular distance
        vx_s1_inertial = np.cos(RA_s1) * np.cos(Dec_s1)
        vy_s1_inertial = np.sin(RA_s1) * np.cos(Dec_s1)
        vz_s1_inertial = np.sin(Dec_s1)

        # the diagnal of the adjacency matrix
        M_adj[i_s1][i_s1] = 0

        for i_s2 in range(i_s1 + 1, num_star):
            data_s2 = lines[i_s2].strip().split()
            assert len(data_s2) == 6

            CN_s2, _, _, _, RA_s2, Dec_s2 = data_s2
            CN_s2, RA_s2, Dec_s2 = int(CN_s2), float(RA_s2), float(Dec_s2)

            # generate unit vector for calculating angular distance
            vx_s2_inertial = np.cos(RA_s2) * np.cos(Dec_s2)
            vy_s2_inertial = np.sin(RA_s2) * np.cos(Dec_s2)
            vz_s2_inertial = np.sin(Dec_s2)

            # if there are some numerous errors, |cos_inertial| may slightly > 1
            cos_inertial = (
                vx_s1_inertial * vx_s2_inertial
                + vy_s1_inertial * vy_s2_inertial
                + vz_s1_inertial * vz_s2_inertial
            )
            AD_inertial = np.arccos(np.clip(cos_inertial, -1, 1)) * rad2deg

            # assign the element of the adjacency matrix
            M_adj[i_s1][i_s2] = AD_inertial
            M_adj[i_s2][i_s1] = AD_inertial

    graph["M_adj"] = M_adj
    return graph, CN_list, XY_list
