# -*- coding: utf-8 -*-
"""
This code is used to generate simulation star images through RightAscension & 
Declination of the stars in FOV of CCD.

The project model of one star is described in 'project_1s' function.

According to the project model, the main star is projected to the center of the 
image. The neighbor star whose AD (angular distance) with main star is less than 
FOV_max is project in the image.

Written in 2020.04.13, revised in 2022.12.06
By Zhiyuan You
"""

import cv2
import numpy as np


# CN: Catalog Number
# VM: Visual Magnitude
# RA: Right Ascension
# Dec: Declination
# AD: Angular Distance
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# _ms: main star
# _ns: neighbor star
# _thre: threshold
# _1s: one star
# _2s: double star


def vis_lines(lines, para):
    num_star = len(lines)
    img = np.zeros((para.N_y, para.N_x, 3), np.uint8)

    data_ms = lines[0].strip().split()
    assert len(data_ms) == 6
    _, VM_ms, x_ms, y_ms, _, _ = data_ms
    VM_ms, x_ms, y_ms = float(VM_ms), float(x_ms), float(y_ms)
    vis_a_star(x_ms, y_ms, VM_ms, img, para)

    for i_ns in range(1, num_star):
        data_ns = lines[i_ns].strip().split()
        assert len(data_ns) == 6
        _, VM_ns, x_ns, y_ns, _, _ = data_ns
        VM_ns, x_ns, y_ns = float(VM_ns), float(x_ns), float(y_ns)
        vis_a_star(x_ns, y_ns, VM_ns, img, para)

    return img


def vis_a_star(x, y, VM, img, para):
    x_pixel = int(x + para.N_x // 2)  # in cv2: (x,y)
    y_pixel = int(y + para.N_y // 2)
    R = min(
        int((para.VM_thre - VM) / para.VM_thre * para.R_max) + 1,
        para.R_max,
    )  # the darkest is 1, the brightest is R_max
    cv2.circle(img, (x_pixel, y_pixel), R, para.Color, -1)


def vis_graph(CN_list, XY_list, para):
    assert len(CN_list) == len(XY_list)
    num_star = len(CN_list)

    img = np.ones((para.N_y, para.N_x, 3), np.uint8) * 255

    for i_s1 in range(num_star):
        CN_s1 = CN_list[i_s1]
        x_s1, y_s1 = XY_list[i_s1]

        # write stars into image
        x1_pixel = int(x_s1 + para.N_x / 2)  # in cv2: (x,y)
        y1_pixel = int(y_s1 + para.N_y / 2)
        cv2.putText(
            img,
            str(CN_s1),
            (x1_pixel, y1_pixel),
            cv2.FONT_HERSHEY_SIMPLEX,
            1,
            (0, 255, 0),
            1,
        )
        cv2.circle(img, (x1_pixel, y1_pixel), para.R_s, para.Color_s, para.Wid_s)

        for i_s2 in range(i_s1 + 1, num_star):
            x_s2, y_s2 = XY_list[i_s2]
            # haldle the edge of graph
            # write the graph edge pic
            x2_pixel = int(x_s2 + para.N_x / 2)  # in cv2: (x,y)
            y2_pixel = int(y_s2 + para.N_y / 2)
            cv2.line(
                img,
                (x1_pixel, y1_pixel),
                (x2_pixel, y2_pixel),
                para.Color_l,
                para.Wid_l,
            )
    return img


def vis_mst(mst, XY_list, para):
    img = (
        np.ones((para.N_y, para.N_x, 3), np.uint8) * 255
    )  # in numpy:(height,width), so:(N_y,N_x)
    # draw the vertex & edge
    for edge_mst in mst:
        i_s1 = edge_mst[1]
        i_s2 = edge_mst[2]
        x_s1, y_s1 = XY_list[i_s1]
        x_s2, y_s2 = XY_list[i_s2]
        x1_pixel = int(x_s1 + para.N_x / 2)  # in cv2: (x,y)
        y1_pixel = int(y_s1 + para.N_y / 2)
        cv2.circle(img, (x1_pixel, y1_pixel), para.R_s, para.Color_s, para.Wid_s)
        x2_pixel = int(x_s2 + para.N_x / 2)  # in cv2: (x,y)
        y2_pixel = int(y_s2 + para.N_y / 2)
        cv2.circle(img, (x2_pixel, y2_pixel), para.R_s, para.Color_s, para.Wid_s)
        cv2.line(
            img,
            (x1_pixel, y1_pixel),
            (x2_pixel, y2_pixel),
            para.Color_l,
            para.Wid_l,
        )
    return img
