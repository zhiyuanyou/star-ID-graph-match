# -*- coding: utf-8 -*-
"""
This code is used for parameter selection, especially for selecting the best radius 
of neighboring circle R. The RightAscension & Declination of the optical axis is 
randomly selected. The R_max is calculated and annalysed. 

The project model of one star is described in 'project_1s' function.

According to the project model, the neighbor star whose AD(angular distance) with 
optical axis is less than min(FOV_x,FOV_y)/2 is project in the image.

Note that stars whose AD is larger or equal than min(FOV_x,FOV_y)/2 still has 
possibility to fall in the image. However, almost all algorithms choose stars 
by a circle centering the main star. The circle's radius is less or euqal than 
min(FOV_x,FOV_y)/2. So stars whose AD is larger or equal than min(FOV_x,FOV_y)/2 
actually have no use.

Written in 2020.02.10, revised in 2022.12.08
by Zhiyuan You
"""


import math
import matplotlib.pyplot as plt
import numpy as np

from easydict import EasyDict

from utils.simulator_helper import project_1s


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec:  Declination
# AD: angular distance
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# _oa: optical axis
# _s: star
# _simu: simulation
# _thre: threshold
# _tp: tangent point


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


def simulate_one(lines, para):
    # randomly select optical axis
    RA_oa = (
        np.random.random() * (para.RA_range[1] - para.RA_range[0]) + para.RA_range[0]
    )
    Dec_oa = (
        np.random.random() * (para.Dec_range[1] - para.Dec_range[0]) + para.Dec_range[0]
    )

    # generate unit vector for calculating angular distance
    vx_oa = np.cos(RA_oa) * np.cos(Dec_oa)
    vy_oa = np.sin(RA_oa) * np.cos(Dec_oa)
    vz_oa = np.sin(Dec_oa)

    dis_min = float("inf")
    for i_s in range(len(lines)):
        data_s = lines[i_s].strip().split()
        assert len(data_s) == 4

        # generate unit vector for calculating angular distance
        _, _, RA_s, Dec_s = data_s
        RA_s, Dec_s = float(RA_s), float(Dec_s)
        vx_s = np.cos(RA_s) * np.cos(Dec_s)
        vy_s = np.sin(RA_s) * np.cos(Dec_s)
        vz_s = np.sin(Dec_s)

        # AD_s_oa: the angular distance between star & optical axis
        cos = vx_s * vx_oa + vy_s * vy_oa + vz_s * vz_oa
        AD_s_oa = np.arccos(np.clip(cos, -1, 1)) * rad2deg

        # x_s, y_s: the project coordinate of star
        x_s, y_s = project_1s(
            Dec_oa, RA_oa, Dec_s, RA_s, para.N_x, para.N_y, para.FOV_x, para.FOV_y
        )
        # dis_s: the distance between star and image center
        dis_s = np.sqrt(x_s**2 + y_s**2)

        if AD_s_oa <= min(para.FOV_x, para.FOV_y) / 2:
            if abs(x_s) > para.N_x / 2 or abs(y_s) > para.N_y / 2:
                print("Error with your projection model! ")
            # find the main star
            if dis_s < dis_min:
                # print(dis_s)
                dis_min = dis_s
                x_s_min = x_s
                y_s_min = y_s

    # calculate the coordinate of the tangent point
    i_min = np.argmin(
        [
            para.N_x / 2 + x_s_min,
            para.N_y / 2 + y_s_min,
            para.N_x / 2 - x_s_min,
            para.N_y / 2 - y_s_min,
        ]
    )
    if i_min == 0:
        x_tp = -para.N_x / 2
        y_tp = y_s_min
    elif i_min == 1:
        x_tp = x_s_min
        y_tp = -para.N_y / 2
    elif i_min == 2:
        x_tp = para.N_x / 2
        y_tp = y_s_min
    elif i_min == 3:
        x_tp = x_s_min
        y_tp = para.N_y / 2
    else:
        raise ValueError

    # generate unit vector for calculating angular distance
    vx_s_min = -x_s_min / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
    vy_s_min = -y_s_min / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
    vz_s_min = 1
    temp_length = np.sqrt(vx_s_min**2 + vy_s_min**2 + vz_s_min**2)
    vx_s_min = vx_s_min / temp_length
    vy_s_min = vy_s_min / temp_length
    vz_s_min = vz_s_min / temp_length

    # generate unit vector for calculating angular distance
    vx_tp = -x_tp / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
    vy_tp = -y_tp / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
    vz_tp = 1
    temp_length = np.sqrt(vx_tp**2 + vy_tp**2 + vz_tp**2)
    vx_tp = vx_tp / temp_length
    vy_tp = vy_tp / temp_length
    vz_tp = vz_tp / temp_length

    # calculate the R_max
    cos = vx_s_min * vx_tp + vy_s_min * vy_tp + vz_s_min * vz_tp
    R_max = np.arccos(cos) * rad2deg
    return R_max


if __name__ == "__main__":
    # simulation parameter
    para = EasyDict({})
    para.VM_thre = 6.0  # Visual Magnitude Threshold
    para.num_simu = 1000
    para.FOV_x = 20  # FOV
    para.FOV_y = 20
    para.N_x = 1024  # resolution
    para.N_y = 1024
    para.RA_range = [0, 2 * math.pi]
    para.Dec_range = [-math.pi / 2, math.pi / 2]

    # read the SAO database
    f_sao_name = f"./database/sao_VM_thre{para.VM_thre}.txt"
    with open(f_sao_name) as fr:
        lines = fr.readlines()

    # save the R_max
    R_max_list = []
    for i_simu in range(para.num_simu):
        print(f"Simulating: {i_simu + 1}")
        R_max = simulate_one(lines, para)
        R_max_list.append(R_max)

    # draw the results
    x_list = np.linspace(4, 10, 100)
    y_list = []
    for R_x in x_list:
        y_pro_R = sum(R_max_list > R_x) / para.num_simu * 100
        y_list.append(y_pro_R)

    plt.plot(x_list, y_list)
    plt.grid()
    plt.xticks(fontsize=14)
    plt.yticks(fontsize=14)
    plt.xlabel("$r^x$/Â°", fontsize=14)
    plt.ylabel("$Proportion$/%", fontsize=14)
    plt.title(
        "Proportion of simulations satisfying $r^x$ < $r^{max}$ with various $r^x$",
    )
    plt.show()
