# -*- coding: utf-8 -*-
"""
This code is used to select the star in R_AD and generate new txt file & image.

Note that R_AD<min(FOV_x,FOV_y), & R_AD is a hyper parameter. 

Written in 2020.01.26, revised in 2022.12.06
By Zhiyuan You
"""

import math
import numpy as np


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec:  Declination
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# x,y: the project coordinate
# AD: angular distance
# _ms: main star
# _ns: neighbor star


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


# choose the star nearest the center as the main star
# input:
# lines contain the stars' information in a star image
# output:
# the index of the main star
def choose_main_star(lines):
    min_dis = float("inf")
    i_ms = None
    for i_s in range(len(lines)):
        data_s = lines[i_s].strip().split()
        assert len(data_s) == 6
        # actually, only the data 'x_s, y_s' are used.
        _, _, x_s, y_s, _, _ = data_s
        x_s = float(x_s)
        y_s = float(y_s)
        dis = np.sqrt(x_s**2 + y_s**2)
        if dis < min_dis:
            min_dis = dis
            i_ms = i_s
    return i_ms


# select the stars arround the main star in R_AD
# input:
# lines contain the stars' information in a star image
# index of the main star
# output:
# lines contain information of stars whose angular distance is less than R_AD
def select_R_AD(lines, para):
    i_ms = choose_main_star(lines)
    data_ms = lines[i_ms].strip().split()
    assert len(data_ms) == 6
    # actually, only the data 'x_ms, y_ms' are used.
    CN_ms, _, x_ms, y_ms, _, _ = data_ms
    CN_ms, x_ms, y_ms = int(CN_ms), float(x_ms), float(y_ms)

    # remove line_ms to 0th element
    line_ms = lines.pop(i_ms)
    lines = [line_ms] + lines

    # generate unit vector for calculating angular distance
    vx_ms = -x_ms / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
    vy_ms = -y_ms / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
    vz_ms = 1
    temp_length = np.sqrt(vx_ms**2 + vy_ms**2 + vz_ms**2)
    vx_ms = vx_ms / temp_length
    vy_ms = vy_ms / temp_length
    vz_ms = vz_ms / temp_length

    for i_ns in range(len(lines) - 1, -1, -1):
        if i_ns == i_ms:
            continue

        data_ns = lines[i_ns].strip().split()
        assert len(data_ns) == 6
        CN_ns, _, x_ns, y_ns, _, _ = data_ns
        CN_ns, x_ns, y_ns = int(CN_ns), float(x_ns), float(y_ns)

        # generate init vector for calculating angular distance
        vx_ns = -x_ns / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
        vy_ns = -y_ns / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
        vz_ns = 1
        temp_length = np.sqrt(vx_ns**2 + vy_ns**2 + vz_ns**2)
        vx_ns = vx_ns / temp_length
        vy_ns = vy_ns / temp_length
        vz_ns = vz_ns / temp_length

        # if there are some numerous errors, |cos| may slightly > 1
        cos = vx_ns * vx_ms + vy_ns * vy_ms + vz_ns * vz_ms
        AD_ms_ns = np.arccos(np.clip(cos, -1, 1)) * rad2deg
        if AD_ms_ns > para.R_AD:
            lines.pop(i_ns)

    return lines
