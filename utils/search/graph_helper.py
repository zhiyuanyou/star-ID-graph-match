# -*- coding: utf-8 -*-
"""
This code is used to generate graph of every main star. 

Each graph is a dictionary, which has the key-value: 'CN_ms':CN_ms,'M_adj':M_adj. 

Note that the following graph match is based only on edges, so the diagonals of 
adjacency matrix M_adj are 0.

Written in 2020.01.26, revised in 2022.12.06
by Zhiyuan You
"""

import math
import numpy as np


# CN: CatalogNumber
# VM: VisualMagnitude
# RA: RightAscension
# Dec:  Declination
# AD: angular distance
# M: matrix
# R: Radius
# vx,vy,vz: unit vector generated by RA & Dec or pixel coordinate
# Wid: width
# x,y: the project coordinate
# _adj: adjacency
# _diag: diagonal
# _l: line
# _ms: main star
# _n0: none zero
# _ns: neighbor star
# _s: star
# _thre: threshold


deg2rad = math.pi / 180
rad2deg = 180 / math.pi


# generate the graph of a star image
# input:
# lines contain information of stars whose AD(angular distance) is less than R_AD
# output:
# the graph of the input stars
def gen_graph(lines, para):
    graph = dict()

    # handle the main star
    CN_ms = int(lines[0].strip().split()[0])

    # add 2 key-values to the graph dict
    graph["CN_ms"] = CN_ms

    # create the adjacency matrix for the graph
    M_adj = np.ones((len(lines), len(lines))) * float("inf")

    for i_s1 in range(len(lines)):
        data_s1 = lines[i_s1].strip().split()
        assert len(data_s1) == 6

        CN_s1, _, x_s1, y_s1, _, _ = data_s1
        CN_s1, x_s1, y_s1 = int(CN_s1), float(x_s1), float(y_s1)

        # generate unit vector for calculating angular distance
        vx_s1_body = -x_s1 / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
        vy_s1_body = -y_s1 / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
        vz_s1_body = 1
        temp_length = np.sqrt(vx_s1_body**2 + vy_s1_body**2 + vz_s1_body**2)
        vx_s1_body = vx_s1_body / temp_length
        vy_s1_body = vy_s1_body / temp_length
        vz_s1_body = vz_s1_body / temp_length

        # the diagnal of the adjacency matrix
        M_adj[i_s1][i_s1] = 0

        for i_s2 in range(i_s1 + 1, len(lines)):
            data_s2 = lines[i_s2].strip().split()
            assert len(data_s2) == 6

            CN_s2, _, x_s2, y_s2, _, _ = data_s2
            CN_s2, x_s2, y_s2 = int(CN_s2), float(x_s2), float(y_s2)

            # generate unit vector for calculating angular distance
            vx_s2_body = -x_s2 / para.N_x * 2 * np.tan(para.FOV_x / 2 * deg2rad)
            vy_s2_body = -y_s2 / para.N_y * 2 * np.tan(para.FOV_y / 2 * deg2rad)
            vz_s2_body = 1
            temp_length = np.sqrt(vx_s2_body**2 + vy_s2_body**2 + vz_s2_body**2)
            vx_s2_body = vx_s2_body / temp_length
            vy_s2_body = vy_s2_body / temp_length
            vz_s2_body = vz_s2_body / temp_length

            # if there are some numerous errors, |cos| may slightly > 1
            cos_body = (
                vx_s1_body * vx_s2_body
                + vy_s1_body * vy_s2_body
                + vz_s1_body * vz_s2_body
            )
            AD_body = np.arccos(np.clip(cos_body, -1, 1)) * rad2deg

            # haldle the edge of graph
            # assign the element of the adjacency matrix
            M_adj[i_s1][i_s2] = AD_body
            M_adj[i_s2][i_s1] = AD_body

    # add M_adj to the graph dict
    graph["M_adj"] = M_adj
    return graph
